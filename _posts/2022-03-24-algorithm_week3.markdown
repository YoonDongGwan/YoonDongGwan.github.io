---
layout: post
title: 2022-03-18 컴퓨터 알고리즘 3주차 - 분할 정복 알고리즘
date: 2022-03-24 090000 +0900
layout: post
---
분할 정복 알고리즘(Divide-and-Conquer)
===
```
분할 정복 알고리즘이란 주어진 문제의 입력을 분할하여 문제를 해결하는 알고리즘이다.
```
위 내용은 '알기 쉬운 알고리즘' 책에 나와있는 분할 정복 알고리즘의 정의이다. 위 내용을 이해하기 위해 아래의 그림을 살펴보자.  

<img src="https://github.com/YoonDongGwan/YoonDongGwan.github.io/blob/main/img/img1.png?raw=true" width="600" height="400"/>
   
위와 같이 크기가 n인 입력이 들어올 때, 이를 쪼개고 쪼개서 결국 더 이상 분할할 수 없을 때까지 나눠 각 부분문제들을 해결해 병합하는 방식이다.
```
입력 크기가 n일 때, $$ \log_2 n $$ 번 분할하면 더 이상 분할할 수 없는 크기인 1이 된다.
```

합병 정렬(Merge Sort)
===
```
합병 정렬은 입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.
```

합병 정렬 알고리즘은 다음과 같다.

```
MergeSort(A,p,q):
if(p < q){
    k = (p+q) / 2
    MergeSort(A,p,k)
    MergeSort(A,k+1,q)
    A[p]~A[k]와 A[k+1]~A[q]를 합병
}
```

입력을 배열로 받아 그 배열을 반으로 나눠 각각 왼쪽, 오른쪽으로 나눠 왼쪽 먼저 재귀 함수 호출로 정렬하고, 그 다음은 오른쪽을 정렬한다.
그 후 왼쪽, 오른쪽을 합병하는 방식이다.

예를 들어, 배열의 크기가 8인 A = [37, 10, 22, 30, 35, 13, 25, 24] 배열이 있다면, 이를 합병 정력 알고리즘을 적용시키면, 아래 그림과 같다.

<img src="https://github.com/YoonDongGwan/YoonDongGwan.github.io/blob/main/img/img2.png?raw=true" width="800" height="450"/>

```
합병 정렬의 시간 복잡도는 O(nlogn)이다.
```

퀵 정렬(Quick Sort)
===

```
퀵 정렬은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다.
```

퀵 정렬에는 피봇(pivot) 이라는 개념이 존재한다. 이 피봇보다 작은 숫자는 왼편으로, 큰 숫자는 오른편에 두는 원리로 정렬하는 방식이다.

퀵 정렬 알고리즘은 아래와 같다.

```
QuickSort(A, left, right):
if(left < right){
    피봇을 하나 선정해 A[left]로 피봇을 옮기고, 피봇과 각 원소들을 비교하기 시작하여, 
    피봇보다 작은 숫자들은 A[left]~A[p-1]로, 피봇보다 큰 숫자들은 A[p+1]~A[right]로
    옮겨 피봇은 A[p]에 놓이게 된다.
    QuickSort(A, left, p-1)
    QuickSort(A, p+1, right)
}
```
입력받은 배열에서 피봇을 하나 설정해, 1차적으로 피봇을 기준으로 정렬하고 후에 피봇의 왼쪽 배열과 오른쪽 배열을 각각 퀵 정렬로 다시 정렬하는 방식이다.  
사실 이 과정은, 분할 후 정복하는 것이 아닌, 정복 후 분할하는 방식이다.

예를 들어, A = [6, 3, 11, 9, 12, 2, 8, 15, 18, 10, 7, 14] 의 배열을 퀵 정렬 알고리즘을 통해 나열해보자. 이 때, 피봇은 배열의 중앙에 위치한 8로 선정하였다.

```
8 3 11 9 12 2 6 15 18 10 7 14
```
먼저 피봇 8을 맨 앞 6과 자리를 바꿨다.
이 다음부턴 3과 14를 비교 후 3부턴 뒤로, 14부턴 앞으로 인덱스를 변경하며, 숫자를 비교하고, 8보다 작은 수는 왼쪽, 큰 수는 오른쪽에 위치시킨다.
```
8 3 11 9 12 2 6 15 18 10 7 14 // 3과 14 비교
```
```
8 3 7 9 12 2 6 15 18 10 11 14 // 11과 7 비교 후 교환
```
```
8 3 7 6 12 2 9 15 18 10 11 14 // 9과 6 비교 후 교환
```
```
8 3 7 6 2 12 9 15 18 10 11 14 // 12과 2 비교 후 교환
```
```
2 3 7 6 8 12 9 15 18 10 11 14 // 그 후 피봇인 8과 2를 교환하면 피봇을 기준으로 왼쪽과 오른쪽이 작은 수와 큰 수로 나뉘었다.
```
이 과정을 다시 왼쪽과 오른쪽 배열에 실행시키는 방식이다.

재귀 함수를 통해 반복시키면 아래와 같이 정렬된다.
```
2 3 6 7 8 9 10 11 12 14 15 18
```
```
퀵 정렬은 피봇 선택에 따라 성능이 좌우 되고, 최악의 시간복잡도는 O(n^2), 최선의 시간복잡도는 O(nlog_2 n)이다.
```
피봇 선정의 방식에는 일반적으로 랜덤으로 선정하는 방식과, 가장 자리 숫자 2개와 중앙의 원소를 비교해 크기가 중간 숫자를 피봇으로 사용하는 방식을 주로 사용한다.


선택 문제
===
선택 문제는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.  
선택 문제를 효율적으로 해결하는데에 있어, 퀵 정렬 알고리즘과 비슷한 방식 사용된다.  
위의 예시와 동일한 배열 A = [6, 3, 11, 9, 12, 2, 8, 15, 18, 10, 7, 14] 가 있다. 이 때, 7번째로 작은 수를 찾으려한다.   
퀵 정렬 알고리즘이 1차적으로 적용된 배열은 아래와 같다.
```
2 3 7 6 8 12 9 15 18 10 11 14 // 피봇을 기준으로 왼쪽과 오른쪽이 작은 수와 큰 수로 나뉘었다.
```
여기서 피봇은 5번째에 위치하게 되었고, 이는 피봇이 5번째로 작은 수라는 의미이다. 우리는 7번째로 작은 수를 찾는 것이 목적이므로, 왼쪽 배열은 모두 버리고, 피봇보다 큰 오른쪽 배열에서 2번째로 작은 수를 찾는다면 원하는 수를 찾는 것이다.  
```
12 9 15 18 10 11 14 // 오른쪽 배열에서 2번째로 작은 수를 찾으면 된다.
```

선택 문제에서도 피봇이 사용되기 때문에, 피봇의 선정에 따라 성능이 좌우되게 된다.

최근접 점의 쌍 찾기
===
최근점 점의 쌍을 찾는 문제에서도 분할 정복 알고리즘이 사용된다.